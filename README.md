# Budget-Travelling
Cost minimisation of hotel stays &amp; airplane tickets for a multi-destination round trip.
Hotel and air-ticket fares were scraped from Trivago and Skyscanner, respectively, and choice of hotels and flights for a 2 month round-trip was formulated as an optimisation problem and solved using PuLP

{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Table of Contents\n",
    "* [Introduction](#intro)\n",
    "* [Getting the Data](#data_gathering)\n",
    "    * [Searching for hotels](#hotel_gather)\n",
    "    * [Searching for flights](#flight_gather)\n",
    "    * [Putting the scrapers to work](#scraper_work)\n",
    "    * [Results](#scrape_res)\n",
    "* [Optimisation Problem](#opt_prob)\n",
    "    * [Formulation](#formulation)\n",
    "    * [PuLP Programming](#pulp)\n",
    "* [Solution](#solution)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Introduction\n",
    "\n",
    "<a id=\"intro\"></a>\n",
    "\n",
    "The worst part of traveling abroad for holidays is that one has to arrange means of transport and book a hotel. But what if we could automate part of the process?\n",
    "\n",
    "Suppose we have a list of destinations (multiple ones) in mind, and a predetermined holiday period. Normally, I would go online, and try to book hotels and flights to accomodate my holiday plan, always keeping cost in mind (unfortunately there's a limit to what I can afford). But what if my PC can answer this simple question: Given a list of destinations, can you find me the flights and hotels I need to book, in order to visit a subset of the destinations, as cheap as possible?\n",
    "\n",
    "Sounds like an optimisation problem, right?\n",
    "\n",
    "# Getting the Data\n",
    "<a id=\"data_gathering\"></a>\n",
    "\n",
    "First things first, we need to define our destinations. Where would we like to go? Luckily, someone has already answered this for us: [Best places to travel in Europe - 2018](https://www.europeanbestdestinations.com/european-best-destinations-2018/).\n",
    "\n",
    "So, the best destinations are the following:\n",
    "- Wroclaw,\n",
    "- Bilbao,\n",
    "- Colmar, \n",
    "- Hvar, \n",
    "- Riga, \n",
    "- Milan, \n",
    "- Athens, \n",
    "- Budapest, \n",
    "- Lisbon, \n",
    "- Bohinj, \n",
    "- Prague, \n",
    "- Kotor, \n",
    "- Paris, \n",
    "- Vienna, \n",
    "- Amsterdam.\n",
    "\n",
    "Next question is, when do we want to go on vacation? Let's assume that we have a month available between July 1st, up to and including August 1st.\n",
    "\n",
    "## Searching for hotels\n",
    "<a id=\"hotel_gather\"></a>\n",
    "\n",
    "Obviously, to answer the question at hand, we need to know how much it costs to stay in a hotel, at any one of the cities listed above, at any time between July 1st to August 1st. We can scrape the data we need from various websites available. Here, we'll use [Trivago](https://www.trivago.com/). The search page looks like the following:\n",
    "![main_hotel](img/trivago_main.png)\n",
    "Clearly, there are a few steps to take:\n",
    "1. Fire up a browser (obviously)\n",
    "2. Check for captchas or 'enable javascript' error messages (the latter tends to happen on Tor)\n",
    "3. Set our country to USA (It's goof to ensure consistency of the text that appears on the website)\n",
    "4. Set the currency to EUR\n",
    "5. Enter the required destination\n",
    "6. Select our check-in date from the drop-down menu\n",
    "7. Select our check-out date from the dropdown menu\n",
    "8. Grab the best offer\n",
    "\n",
    "Of course, we have to repeat most steps to gather all the data we need. We'll also implement some 'waiting periods' in-between these actions, as there's no reason to strain the server with our requests. Let's write our scraper using Selenium and the Tor web browser (for info on getting Selenium to work nicely with Tor, check: https://stackoverflow.com/questions/15316304/open-tor-browser-with-selenium):\n",
    "\n",
    "### Hotel Offer Web Scraper\n",
    "<a id=\"hotel_scraper\"></a>\n",
    "\n",
    "First of all, let's instantiate our scraper class:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from tbselenium.tbdriver import TorBrowserDriver\n",
    "from selenium.webdriver.common.keys import Keys\n",
    "from selenium.common.exceptions import NoSuchElementException\n",
    "from selenium.webdriver.support.ui import Select\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as ec\n",
    "from selenium.webdriver.common.by import By\n",
    "from tbselenium.utils import start_xvfb, stop_xvfb\n",
    "\n",
    "from datetime import datetime as dt\n",
    "from datetime import timedelta\n",
    "from time import sleep\n",
    "\n",
    "from multiprocessing import Pool, cpu_count, Manager\n",
    "\n",
    "from itertools import product\n",
    "from functools import partial\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import pulp as plp\n",
    "\n",
    "# Imports specifically for jupyter\n",
    "import jdc\n",
    "\n",
    "# Path for TOR\n",
    "DRIVER_PATH = '/tor-browser/tor-browser_en-US/'\n",
    "\n",
    "class Hotel_Scraper(object):\n",
    "    \n",
    "    def __init__(self):\n",
    "        \n",
    "        self.url = \"https://www.trivago.com/\"\n",
    "        self.implicit_wait = 5 # Wait in between actions\n",
    "        self.wait_for_elem = 20 # Wait up to 20 seconds for an element to appear, be clickable, etc.\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Right. Now we need to write our functions that perform steps 1 - 8 above. Step 1 will be performed in the end. Let's begin with steps 2 - 4:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    # Check whether a captcha has appeared\n",
    "    def is_captcha(self):\n",
    "        \n",
    "        try:\n",
    "            css_selector_tag = 'main.main-content > section.pos-relative.clearfix > div.centerwrapper--narrow.m-0-auto > div.gutter-box.mb-gutter-doubled.bg-white.border-radius.opacity-high.ta-center > h2.h2'\n",
    "            self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "            return True\n",
    "        except:\n",
    "            # No captcha mentioned\n",
    "            return False\n",
    "\n",
    "\n",
    "    # Check whether a 'enable javascript' msg has appeared\n",
    "    def is_js_alert(self):\n",
    "        \n",
    "        try:\n",
    "            # Try and get the alert on the top of the page\n",
    "            css_selector_tag = 'body > span > div.alert.alert--info.alert--top > p.alert__message > a'\n",
    "            alert            = self.browser.find_element_by_css_selector(css_selector_tag).get_attribute(\"href\")\n",
    "            # Does it say anything about javascript?\n",
    "            if 'javascript' in alert:\n",
    "                return True\n",
    "        except:\n",
    "            # No js. alert\n",
    "            return False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The best thing we can do, if any of the two alerts appear is to refresh the page and hope they don't appear again. There must be something more efficient we can do, I didn't find it though. Let's write a small function to refresh the page:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    # Refresh on bot or js alert\n",
    "    def refresh(self):\n",
    "        \n",
    "        # Keep refreshing until there's no javascript alert or a captcha\n",
    "        while self.is_captcha() or self.is_js_alert():\n",
    "            \n",
    "            # Close the current browser\n",
    "            self.browser.close()\n",
    "            \n",
    "            # Fire up a new browser\n",
    "            self.browser = TorBrowserDriver(DRIVER_PATH)\n",
    "            self.browser.implicitly_wait(self.implicit_wait) \n",
    "            self.browser.set_window_size(1024, 768)\n",
    "            self.browser.get(self.url)\n",
    "    \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. Next up, we need to set the country and currency. Pretty simple:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    " %%add_to Hotel_Scraper\n",
    "    \n",
    "    # Set country to USA\n",
    "    def set_country(self):\n",
    "        \n",
    "        # Find the dropdown menu\n",
    "        xpath_tag = \"//select[contains(@id, 'select-country')]\"\n",
    "        country_btn = Select(self.browser.find_element_by_xpath(xpath_tag))\n",
    "        \n",
    "        # Set it to US\n",
    "        country_btn.select_by_value(\"us\")\n",
    "        \n",
    "        return\n",
    "        \n",
    "    # Set currency to EUR\n",
    "    def set_currency(self):\n",
    "        \n",
    "        # Find the currency selector\n",
    "        currency_btn = Select(self.browser.find_element_by_css_selector(\"select#currency\"))\n",
    "                                                                   \n",
    "        # Set it to EURO\n",
    "        currency_btn.select_by_value(\"EUR\")\n",
    "        \n",
    "        # Wait a bit\n",
    "        sleep(5)\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Right. Now we can start filling in our details. Let's begin with our destination. We need a function to take a string (destination) as input, and a boolean indicating if this is the first time we're searching something on the current session (some additional steps are needed):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    def enter_destination(self, destination, first_search):\n",
    "        \n",
    "        # Destination input\n",
    "        css_selector_tag  = \"input#horus-querytext\"\n",
    "        destination_input = self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "        destination_input.send_keys(destination)\n",
    "        \n",
    "        # Wait until the selection pop-up becomes available\n",
    "        css_selector_tag = \"div.ssg-suggestion__info\"\n",
    "        wait             = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.visibility_of_element_located((By.CSS_SELECTOR, css_selector_tag)))\n",
    "        \n",
    "        if first_search:\n",
    "            # Click tab twice and hit enter (move to the next input)\n",
    "            destination_input.send_keys(Keys.TAB)\n",
    "            destination_input.send_keys(Keys.TAB)\n",
    "            destination_input.send_keys(Keys.ENTER)\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we need functions to enter the check-in and check-out dates. After having some brief inspection of the page's HTML code, I decided its easy to combine both functions in one, as there are only some minor differences in the names of the buttons that have to be pressed, which will be given as inputs to the function. Moreover, we need to account for the fact that, if this is our first search in the session, we need to click on a few extra things:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    # Enter check_in date\n",
    "    def enter_date(self, check_in_date, first_search, xpath_tag):\n",
    "        \n",
    "        if not first_search: \n",
    "            self.browser.find_element_by_xpath(xpath_tag).click()\n",
    "            wait = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "            wait.until(ec.visibility_of_element_located((By.XPATH, xpath_tag)))\n",
    "        \n",
    "        # Get the month that appeared in the dropdown menu\n",
    "        css_selector_tag = 'th#cal-heading-month.cal-heading-month > span'\n",
    "        menu_month       = self.browser.find_element_by_css_selector(css_selector_tag).text\n",
    "        \n",
    "        # Parse it\n",
    "        menu_month = dt.strptime(menu_month, \"%B %Y\").month\n",
    "        \n",
    "        # Parse check in date\n",
    "        check_in_date_parsed = dt.strptime(check_in_date, \"%d/%m/%Y\")\n",
    "        \n",
    "        # Get the difference in months (i.e how many times to hit the button)\n",
    "        delta = check_in_date_parsed.month - menu_month\n",
    "        \n",
    "        # Get the next month button\n",
    "        css_selector_tag  = \"button.cal-btn-next\"\n",
    "        next_month_button = self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "        \n",
    "        # Click it an appropriate number of times\n",
    "        for _ in range(delta):\n",
    "            next_month_button.click()\n",
    "        \n",
    "        # Grab the calendar web element again (avoid stale reference error)\n",
    "        css_selector_tag = \"div.df_container_calendar\"\n",
    "        calendar_elem    = self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "        \n",
    "        # Click on the right button\n",
    "        xpath_tag = \"//time[@datetime='\" + check_in_date[-4:] + '-' + check_in_date[3:5] + '-'+ check_in_date[0:2] + \"']\"\n",
    "        wait      = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        \n",
    "        wait.until(ec.visibility_of_element_located((By.XPATH, xpath_tag)))\n",
    "        calendar_elem.find_element_by_xpath(xpath_tag).click()\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next up, we need to fill in the room info. Namely, the number of adults:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    def enter_room_info(self, adults):\n",
    "        \n",
    "        # Depending on the IP, two different dropdown menus appear\n",
    "        try:\n",
    "            # Get the dropdown menu\n",
    "            css_selector_tag = \"ul.df_container_roomtype_selector.df_dropdown\"\n",
    "            room_menu        = self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "            \n",
    "        except NoSuchElementException:\n",
    "            # Get the current no. of adults\n",
    "            xpath_tag      = \"//input[contains(@id, 'adults-input')]\"\n",
    "            current_adults = self.browser.find_element_by_xpath(xpath_tag)\n",
    "            current_adults = int(current_adults.get_attribute(\"ID\")[-1])\n",
    "            \n",
    "            # Figure out how many types to click on the plus/minus button\n",
    "            delta = adults - current_adults\n",
    "            \n",
    "            if delta < 0:\n",
    "                # Grab the minus button\n",
    "                css_tag = \"div.room-filters__content > button.circle-btn.circle-btn--minus\"\n",
    "                btn     = self.browser.find_element_by_css_selector(css_tag)\n",
    "                \n",
    "                # Make delta positive\n",
    "                delta = abs(delta)\n",
    "            elif delta > 0:\n",
    "                # Grab the plus button\n",
    "                css_tag = \"div.room-filters__content > button.circle-btn.circle-btn--plus\"\n",
    "                btn     = self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "                \n",
    "            for _ in range(delta):\n",
    "                btn.click()\n",
    "            \n",
    "        else:\n",
    "            # Click on the double room (2nd element from the list)\n",
    "            css_tag = 'li.roomtype-item'\n",
    "            rooms   = room_menu.find_elements_by_css_selector(css_tag)\n",
    "            rooms[1].click()\n",
    "        \n",
    "        return\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. Finally, we need to collect the best offer identified by the website. The results returned are already sorted according to their recommendations algorithm, so we just need to grab the first offer we get (I trust that their recommender is a good one :)). A typical result returned is the following:\n",
    "\n",
    "![typical_result_hotel](img/trivago_typical_result.png)\n",
    "\n",
    "There are a few things we need from this tab: Hotel name, no. stars, the website that offers the deal, and the total price. Let's also add check-in and check-out dates on this list so that we can make a one-line dataframe that will be later appended to the rest of the results:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    # Get the best offer according to website\n",
    "    def get_offer(self, destination, check_in_date, check_out_date):    \n",
    "        \n",
    "        # Wait until the loader exits\n",
    "        xpath_tag = \"//span[@class='loader-text.center-x']\"\n",
    "        wait      = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.invisibility_of_element_located((By.XPATH, xpath_tag)))\n",
    "        \n",
    "        # Grab the first result (already sorted)\n",
    "        xpath_tag = \"//li[@class='hotel-item item-order__list-item js_co_item']\"\n",
    "        offer     = self.browser.find_element_by_xpath(xpath_tag)\n",
    "        \n",
    "        # Get hotel name\n",
    "        css_selector_tag = \"span.item-link.name__copytext\"\n",
    "        name             = offer.find_element_by_css_selector(css_selector_tag)\n",
    "        name             = name.text\n",
    "        \n",
    "        # Get no stars\n",
    "        css_selector_tag = \"div.stars-wrp > span.icon-ic.star\"\n",
    "        stars            = len(offer.find_elements_by_css_selector(css_selector_tag))\n",
    "        \n",
    "        # Get deal website\n",
    "        css_selector_tag = \"em.item__deal-best-ota.block.fs-normal.cur-pointer--hover\"\n",
    "        website          = offer.find_element_by_css_selector(css_selector_tag).text\n",
    "        \n",
    "        # Get total price\n",
    "        try:\n",
    "            # One night stays\n",
    "            css_selector_tag = \"em.item__per-night.fs-normal > span\"\n",
    "            price            = offer.find_element_by_css_selector(css_selector_tag).text\n",
    "            \n",
    "        except:\n",
    "            # More than one night stays (different element is needed)\n",
    "            css_selector_tag = \"strong.item__best-price.price_min\"\n",
    "            price            = offer.find_element_by_css_selector(css_selector_tag).text\n",
    "            \n",
    "        # Remove Euro sign, remove thousands separator, and convert to int\n",
    "        price = int(price.replace(\"â‚¬\",\"\").replace(\".\",\"\").replace(\",\",\"\"))\n",
    "        \n",
    "        # concatenate results\n",
    "        df = pd.DataFrame({\"city\" :      destination,\n",
    "                           \"check_in\" :  check_in_date,\n",
    "                           \"check_out\" : check_out_date,\n",
    "                           \"hotel\" :     name,\n",
    "                           \"stars\" :     stars,\n",
    "                           \"offered_by\": website,\n",
    "                           \"price\" :     price}, \n",
    "                          index = [0])\n",
    "        \n",
    "        return df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. The few small steps that remain from the list can be implemented directly on our main function. The inputs to our main function will be a dict containing a 'destinations' list, 'start_dates', 'end_dates' lists, and the number of adults for the room:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Hotel_Scraper\n",
    "\n",
    "    # Main\n",
    "    def run(self, inputs):\n",
    "        \n",
    "        # Fire up a browser with the main page\n",
    "        self.browser = TorBrowserDriver(DRIVER_PATH)\n",
    "        self.browser.set_window_size(1024, 768)\n",
    "        self.browser.implicitly_wait(self.implicit_wait) \n",
    "        self.browser.get(self.url)\n",
    "    \n",
    "        # Refresh on js alert or bot message\n",
    "        self.refresh()\n",
    "        \n",
    "        # Change country to USA\n",
    "        self.set_country()\n",
    "        \n",
    "        # Set to EURO currency\n",
    "        self.set_currency()\n",
    "        \n",
    "        # Start scraping\n",
    "        first_search = True\n",
    "        dfs          = []\n",
    "        \n",
    "        # Enter destination\n",
    "        for destination in inputs[\"destinations\"]:\n",
    "            \n",
    "            self.enter_destination(destination, first_search)\n",
    "            \n",
    "            for check_in_date, check_out_date in zip(inputs[\"start_dates\"], inputs[\"end_dates\"]):\n",
    "                    \n",
    "                    # Enter check-in date\n",
    "                    xpath_tag = \"//button[@data-qa='calendar-checkin']\"\n",
    "                    self.enter_date(check_in_date, first_search, xpath_tag)\n",
    "                    \n",
    "                    # Enter check-out date\n",
    "                    xpath_tag = \"//button[@data-qa='calendar-checkout']\"\n",
    "                    self.enter_date(check_out_date, first_search, xpath_tag)\n",
    "                     \n",
    "                    # Fill in room info on the first time only (saved afterwards)\n",
    "                    if first_search:\n",
    "                        self.enter_room_info(inputs[\"no_adults\"])\n",
    "                    \n",
    "                    # Search\n",
    "                    css_selector_tag = \"button.btn.btn--primary.js-search-button.horus-btn-search\"\n",
    "                    self.browser.find_element_by_css_selector(css_selector_tag).click()\n",
    "                    \n",
    "                    # Get offer\n",
    "                    dfs.append(self.get_offer(destination, check_in_date, check_out_date))\n",
    "                    \n",
    "                    # Set the 'first time search' flag to false, and update the previous check in date\n",
    "                    first_search           = False\n",
    "                    previous_check_in_date = check_in_date\n",
    "                    \n",
    "        # Close window\n",
    "        self.browser.quit()        \n",
    "                \n",
    "        # Gather results\n",
    "        df = pd.concat(dfs, ignore_index = True)    \n",
    "        \n",
    "        return df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Searching for flights\n",
    "<a id=\"flight_gather\"></a>\n",
    "In a similar way, we can gather the data we need for the flights between our destinations. For this, we'll use [Skyscanner](https://www.skyscanner.com). The search tab looks like this:\n",
    "\n",
    "![main_hotel](img/skyscanner_main.png)\n",
    "\n",
    "Once again, we need to perform the following steps:\n",
    "1. Fire up a browser (obviously)\n",
    "2. Check for captchas or 'enable javascript' error messages (the latter tends to happen on Tor)\n",
    "3. Choose one-way flights\n",
    "4. Set the currency to EUR\n",
    "5. Enter the traveler info\n",
    "6. Set inbound city\n",
    "7. Set outbound city\n",
    "8. Select flight date\n",
    "9. Grab the result (if results exist)\n",
    "\n",
    "Let's begin writing our flight scraper. Once again, we'll be using Selenium and Tor.\n",
    "First of all, let's instantiate a scraper:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Flight_Scraper(object):\n",
    "    \n",
    "    def __init__(self):\n",
    "        # Initialize\n",
    "        self.url           = \"https://www.skyscanner.com\"\n",
    "        self.implicit_wait = 10 # Wait in between actions\n",
    "        self.wait_for_elem = 20 # Wait up to 20 seconds for an element to appear, be clickable, etc."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's begin implementing the steps mentioned above. First of all, a coule function to refresh the page if a captcha or a javascript error appears:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Check for exception on start\n",
    "    def exception_on_start(self):\n",
    "        \n",
    "        try:\n",
    "            # Fire up the main page\n",
    "            self.browser.get('https://www.skyscanner.com')\n",
    "            sleep(self.wait_for_elem + 1) # Wait to see if the timeout exception will be thrown\n",
    "            return False\n",
    "        except TimeoutException or WebDriverException:\n",
    "            return True\n",
    "    \n",
    "    # Refresh on timeout or webdriver exception\n",
    "    def refresh(self):\n",
    "        \n",
    "        # Keep refreshing until there's no javascript alert or a captcha\n",
    "        while self.exception_on_start():\n",
    "            \n",
    "            # Fire up a new browser\n",
    "            self.browser = TorBrowserDriver(DRIVER_PATH)\n",
    "            self.browser.implicitly_wait(self.implicit_wait) \n",
    "    \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Sometimes, an annoying login prompt appears. Let's remove it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Remove login prompt\n",
    "    def supress_login_prompt(self):\n",
    "        \n",
    "        # Remove annoying login prompt if it exists\n",
    "        try:\n",
    "            xpath = \"//div[contains(@class, 'LoginPrompt')]\"\n",
    "            self.browser.find_element_by_xpath(xpath)\n",
    "        except:\n",
    "            # If it doesn't exist - do nothing\n",
    "            pass\n",
    "        else:\n",
    "            # If it exists close it\n",
    "            css_selector_tag = \"button.bpk-close-button-65MQ0.bpk-modal__close-button-2a-Xb\"\n",
    "            self.browser.find_element_by_css_selector(css_selector_tag).click()\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's set the currency to EUR:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Set currency to EUR\n",
    "    def set_currency(self):\n",
    "        # Click on the culture info button\n",
    "        self.browser.find_element_by_css_selector(\"li#culture-info > button\").click()\n",
    "        \n",
    "        # Wait for the appropriate element (currency selector) to become available\n",
    "        wait = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.visibility_of_element_located((By.ID, \"culture-selector-currency\")))\n",
    "    \n",
    "        # Once it does, click it\n",
    "        currency_btn = Select(self.browser.find_element_by_id(\"culture-selector-currency\"))\n",
    "        currency_btn.select_by_value(\"EUR\")\n",
    "        \n",
    "        # Click on save\n",
    "        self.browser.find_element_by_id(\"culture-selector-save\").click()\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, there's a bit more code required to fill in the passenger info. Namely, to select the correct number of adults:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Fill in traveller info\n",
    "    def enter_traveller_info(self, no_adults):\n",
    "        \n",
    "        # Click on the cabin, class & travellers button\n",
    "        xpath_tag = \"//button[contains(@id, 'CabinClassTravellersSelector')]\"\n",
    "        \n",
    "        # wait until it is not obscured by something else\n",
    "        wait = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.invisibility_of_element_located((By.CLASS_NAME, 'bpk-scrim-2oT4Y')))\n",
    "        \n",
    "        # once it does, click it\n",
    "        self.browser.find_element_by_xpath(xpath_tag).click()\n",
    "                        \n",
    "        # Enter adult info\n",
    "        self.enter_adult_info(no_adults)\n",
    "        \n",
    "        # CLick on the done button\n",
    "        xpath_tag = \"//footer[contains(@class, 'BpkPopover_bpk-popover__footer')]//button\"\n",
    "        self.browser.find_element_by_xpath(xpath_tag).click()\n",
    "        \n",
    "        return\n",
    "    \n",
    "    # Enter the required information about adults\n",
    "    def enter_adult_info(self, no_adults):\n",
    "        \n",
    "        # Find the adults button\n",
    "        xpath_tag = \"//button[@aria-controls='search-controls-adults-nudger']\"\n",
    "        \n",
    "        # Wait until it becomes available\n",
    "        wait = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.visibility_of_any_elements_located((By.XPATH, xpath_tag)))\n",
    "        \n",
    "        increase_adults_btn = self.browser.find_elements_by_xpath(xpath_tag)[1]\n",
    "        \n",
    "        # CLick the button an appropriate number of times\n",
    "        for _ in range(1, no_adults):\n",
    "            increase_adults_btn.click()\n",
    "            \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. Next up, we need two functions to enter the origin and destination airports:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Enter outbound airport\n",
    "    def enter_origin(self, city_from):\n",
    "        \n",
    "        # Wait until the search button is visible \n",
    "        wait = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.visibility_of_element_located((By.ID, \"fsc-origin-search\")))\n",
    "        origin_input = self.browser.find_element_by_id(\"fsc-origin-search\")\n",
    "        origin_input.clear()\n",
    "        origin_input = self.browser.find_element_by_id(\"fsc-origin-search\")\n",
    "        origin_input.send_keys(city_from)\n",
    "            \n",
    "        # Wait until autosuggest gives a matching result\n",
    "        css_selector_tag = \"div#react-autowhatever-fsc-origin-search\"\n",
    "        wait             = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.visibility_of_element_located((By.CSS_SELECTOR, css_selector_tag)))\n",
    "            \n",
    "        # Hit tab once it does\n",
    "        origin_input.send_keys(Keys.TAB)\n",
    "        \n",
    "        return\n",
    "    \n",
    "    \n",
    "    #Enter destination airport\n",
    "    def enter_destination(self, city_to):\n",
    "        \n",
    "        destination_input = self.browser.find_element_by_id(\"fsc-destination-search\")\n",
    "        destination_input.clear()\n",
    "        destination_input = self.browser.find_element_by_id(\"fsc-destination-search\")\n",
    "        destination_input.send_keys(city_to)\n",
    "            \n",
    "        # Wait until autosuggest gives a matching result\n",
    "        css_selector_tag = \"div#react-autowhatever-fsc-destination-search\"\n",
    "        wait             = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "        wait.until(ec.visibility_of_element_located((By.CSS_SELECTOR, css_selector_tag)))\n",
    "            \n",
    "        # Hit tab once it does\n",
    "        destination_input.send_keys(Keys.TAB)\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Nice. Next step is to enter the departure date:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Enter departure date\n",
    "    def enter_departure_date(self, date):\n",
    "        \n",
    "        # Get the date element\n",
    "        self.browser.find_element_by_id(\"depart-fsc-datepicker-button\").click()\n",
    "        \n",
    "        # Select the appropriate  month\n",
    "        css_selector = 'select#depart-calendar__bpk_calendar_nav_select'\n",
    "        month_btn    = Select(self.browser.find_element_by_css_selector(css_selector))\n",
    "        month        = date[-4:] + '-' + date[3:5] # Grab year and month from the input\n",
    "        month_btn.select_by_value(month) # Select it\n",
    "                        \n",
    "        # Select the appropriate day of the month\n",
    "        # Grab the <dd> part of the day and remove any leading zeros\n",
    "        day = date[:2].lstrip('0')\n",
    "                        \n",
    "        # Grab the table element with the dates\n",
    "        date_table = self.browser.find_element_by_xpath(\"//table[starts-with(@class, 'BpkCalendarGrid')]//tbody\")\n",
    "                    \n",
    "        # Iterate over all the buttons (couldn't find an appropriate xpath constructor for this)\n",
    "        for btn in date_table.find_elements_by_css_selector('button'):\n",
    "            \n",
    "            # Select the appropriate one and click it\n",
    "            if 'outside__tumet' not in btn.get_attribute('class') and btn.text == day:\n",
    "                btn.click()\n",
    "                break\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we need to collect the results that are returned. Once again, results are soted according to price and most convenient departure time, so we just need to grab the first result returned (if at all). A typical result looks like this:\n",
    "\n",
    "![flight_result](img/skyscanner_typical_result.png)\n",
    "\n",
    "From this, we can collect the price, operator and flight number, as well as departure and arrival times:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Gather the results\n",
    "    def scrape_page(self, city_from, city_to, date):\n",
    "        \n",
    "        # There's a chance that a flight cannot be found on that day\n",
    "        \n",
    "        try: # Check if there are no flights on that day\n",
    "            css_selector_tag = \"div.fss-fxo-legs\"\n",
    "            self.browser.find_element_by_css_selector(css_selector_tag)\n",
    "            \n",
    "            # No flight found!\n",
    "            df = pd.DataFrame({\"city_from\" : city_from,\n",
    "                               \"city_to\" :   city_to,\n",
    "                               \"date\" :      date,\n",
    "                               \"flight\" :    \"None\",\n",
    "                               \"departure\" : \"None\",\n",
    "                               \"arrival\":    \"None\",\n",
    "                               \"price\" :     99999}, \n",
    "                              index = [0])\n",
    "            \n",
    "        except:\n",
    "            # Grab the best offer (automatically sorted)\n",
    "            xpath_tag = \"//li[contains(@class, day-list-item.ItinerariesContainer)]//div//div//article\"\n",
    "            offer     = self.browser.find_element_by_xpath(xpath_tag)\n",
    "        \n",
    "            # Get the price\n",
    "            xpath_tag  = \"//a[contains(@class, 'CTASection__total-price')]\"\n",
    "            price_text = offer.find_element_by_xpath(xpath_tag).text\n",
    "            \n",
    "            # Get numbers delimited by word boundaries (space, period, comma), i.e. the price\n",
    "            price = int(re.findall(r'\\b\\d+\\b', price_text)[0])\n",
    "            \n",
    "            # Click the go-to button\n",
    "            xpath_tag = \"//button[@class='bpk-button CTASection__cta-button-JozPr']\"\n",
    "            offer.find_element_by_xpath(xpath_tag).click()\n",
    "            \n",
    "            # Get the summary\n",
    "            css_selector = 'div.ItineraryLeg__leg-summary-container-qSDzV.clearfix'\n",
    "            self.browser.find_element_by_css_selector(css_selector).click()\n",
    "            \n",
    "            xpath_tag = '//div[contains(@class, ItineraryLeg__leg-summary-details)]'\n",
    "            summary   = self.browser.find_element_by_xpath(xpath_tag)\n",
    "            \n",
    "            # From the summary get the operator\n",
    "            xpath_tag = \"//span[contains(@class, 'ItineraryLeg__operated-by')]\"\n",
    "            operator  = summary.find_element_by_xpath(xpath_tag).text\n",
    "            \n",
    "            # From the summary get the departure, arrival times and flight duration\n",
    "            xpath_tag = \"//div//div[contains(@class, 'ItineraryLeg__segment-times')]\"\n",
    "            times     = summary.find_element_by_xpath(xpath_tag).text.split('\\n')\n",
    "            dep_time  = times[0] # departure time\n",
    "            arr_time  = times[1] # Arrival time\n",
    "            \n",
    "            # concatenate results\n",
    "            df = pd.DataFrame({\"city_from\" : city_from,\n",
    "                               \"city_to\" :   city_to,\n",
    "                               \"date\" :      date,\n",
    "                               \"flight\" :    operator,\n",
    "                               \"departure\" : dep_time,\n",
    "                               \"arrival\":    arr_time,\n",
    "                               \"price\" :     price}, \n",
    "                              index = [0])\n",
    "        \n",
    "        \n",
    "        return df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. Now, let's put the flight scraper together:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Flight_Scraper\n",
    "\n",
    "    # Main\n",
    "    def run(self, inputs):\n",
    "        \n",
    "        # Fire up a new browser\n",
    "        self.browser = TorBrowserDriver(DRIVER_PATH)\n",
    "        self.browser.implicitly_wait(self.implicit_wait) \n",
    "        \n",
    "        # Refresh on error\n",
    "        self.refresh()\n",
    "        \n",
    "        # We want one-way flights\n",
    "        self.browser.find_element_by_id(\"fsc-trip-type-selector-one-way\").click()\n",
    "            \n",
    "        # We want prices in euros\n",
    "        self.set_currency()\n",
    "        \n",
    "        # Enter traveller info\n",
    "        self.enter_traveller_info(inputs[\"no_adults\"])\n",
    "        \n",
    "        # empty list to hold results\n",
    "        dfs = []\n",
    "        \n",
    "        # Iterate over all city pairs and dates\n",
    "        for city_from in inputs[\"city_from\"]:\n",
    "            for city_to in inputs[\"city_to\"]:\n",
    "               \n",
    "                # Outbound city\n",
    "                self.enter_origin(city_from)\n",
    "                    \n",
    "                # Inbound city\n",
    "                self.enter_destination(city_to)\n",
    "                \n",
    "                for date in inputs[\"departure_dates\"]:\n",
    "                    \n",
    "                    # Flight date\n",
    "                    self.enter_departure_date(date)\n",
    "                            \n",
    "                    # Search flights\n",
    "                    xpath_tag = \"//button[contains(@class, 'SubmitButton')]\"\n",
    "                    self.browser.find_element_by_xpath(xpath_tag).click()\n",
    "                    \n",
    "                    # Close login prompt (if it exists)\n",
    "                    self.supress_login_prompt()\n",
    "                    \n",
    "                    # Wait for the progress bar to disappear \n",
    "                    wait = WebDriverWait(self.browser, self.wait_for_elem)\n",
    "                    wait.until(ec.invisibility_of_element_located((By.XPATH, \"//div[@class='day-search-progress']\")))\n",
    "                    \n",
    "                    # Get results and put them to list\n",
    "                    dfs.append(self.scrape_page(city_from, city_to, date))\n",
    "                \n",
    "                    # Go back to homepage\n",
    "                    self.browser.get('https://www.skyscanner.com')\n",
    "                    \n",
    "        # Close window\n",
    "        self.browser.quit()        \n",
    "            \n",
    "        # Gather results\n",
    "        df = pd.concat(dfs, ignore_index = True)        \n",
    "        \n",
    "        return df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Once again, the inputs to the flight scraper will be a dict, containing lists with the number of adults (this one is constant), inbound and outbound cities, as well as departure dates."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Putting the scrapers to work\n",
    "\n",
    "<a id=\"scraper_work\"></a>\n",
    "\n",
    "Right, we've built our scrapers so far. Now we need to set them to work. The easiest thing to do to speed up the process of gathering the data, is to set them to run in parallel. Let's wrap them in another class, whose aim is to fire up the multiple scrapers (workers), distribute the queries among them, collect the results from each scraping session, and write them to a file. Let's begin (once again):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Scraper(object):\n",
    "    \n",
    "    # Initialize\n",
    "    def __init__(self, filename, scrape_type, max_job, no_processes, queries_per_process = 1):\n",
    "        \n",
    "        self.scrape_type         = scrape_type         # Scrape hotel or flight data?\n",
    "        self.max_job             = max_job             # No. of jobs that will be performed by the scraper\n",
    "        self.no_processes        = no_processes        # No. of processes to start\n",
    "        self.queries_per_process = queries_per_process # No. of queries per process\n",
    "        self.filename            = filename            # Filename to write outputs\n",
    "        \n",
    "        # Input check\n",
    "        if self.scrape_type not in ['hotel', 'flight']:\n",
    "            raise ValueError('Invalid scraper type')\n",
    "            \n",
    "        # Date format for the flight and hotel scrapers\n",
    "        self.date_format = \"%d/%m/%Y\"\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's write the main part of the program first, and then start making the functions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Scraper\n",
    "\n",
    "    # Main\n",
    "    def run(self, destinations, start_date, end_date, no_adults):\n",
    "    \n",
    "        # Generate inputs for each process\n",
    "        scraper_inputs = self.generate_inputs(destinations, start_date, end_date, no_adults)\n",
    "        \n",
    "        # Manager to manage the queue and make it accessible to the different workers\n",
    "        m = Manager()\n",
    "        \n",
    "        # Make the queue\n",
    "        q = m.Queue()\n",
    "        \n",
    "        # Make the pool\n",
    "        p = Pool(self.no_processes)\n",
    "    \n",
    "        # Fire up the workers\n",
    "        processes_running = p.starmap_async(partial(self.worker, queue = q), scraper_inputs) \n",
    "        \n",
    "        # Fire up the listener\n",
    "        self.listener(self.filename, q, processes_running)\n",
    "        \n",
    "        # Exiting: kill the pool\n",
    "        p.close()\n",
    "        p.join()\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This should be farly easy to understand. The generate_inputs() function will generate a list of inputs for each worker, which will be distributed on the worker() function (i.e. the scraper) by the starmap_async() function, and the listener() process will be responsible of collecting the data when one of the workers exits, and write them to a CSV file. \n",
    "\n",
    "Let's write the generate_inputs() function. This will take a dictionary containing a list of destinations, one start and one end date, and the number of adults. It will return a list of dicts of equal length, each dict containing the inputs for each worker:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Scraper\n",
    "\n",
    "    # Generate a list of dicts for the flight and hotel scraper    \n",
    "    def generate_inputs(self, destinations, start_date, end_date, no_adults):\n",
    "        \n",
    "        # Scraping hotels\n",
    "        if self.scrape_type == 'hotel':\n",
    "            scraper_inputs = self.hotel_scraper_input_list(destinations, \n",
    "                                                           start_date, \n",
    "                                                           end_date,\n",
    "                                                           no_adults,\n",
    "                                                           self.date_format)\n",
    "        # Scraping flights\n",
    "        else:\n",
    "            scraper_inputs = self.flight_scraper_input_list(destinations, \n",
    "                                                            start_date, \n",
    "                                                            end_date, \n",
    "                                                            no_adults,\n",
    "                                                            self.date_format)\n",
    "        \n",
    "        print('Total number of jobs: ', len(scraper_inputs))\n",
    "        \n",
    "        # Get the appropriate inputs\n",
    "        remaining_jobs = self.get_remaining_jobs()\n",
    "        scraper_inputs = [(idx, inputs) for (idx, inputs) in scraper_inputs if idx in remaining_jobs]\n",
    "        \n",
    "        return scraper_inputs\n",
    "    \n",
    "    \n",
    "    # Return a list of equal query-sized inputs for the flight scraper processes\n",
    "    @staticmethod\n",
    "    def flight_scraper_input_list(destinations, start_date, end_date, no_adults, date_format):\n",
    "        \n",
    "        # Parse starting and ending dates for the trip\n",
    "        tStart = dt.strptime(start_date, date_format) \n",
    "        tEnd   = dt.strptime(end_date, date_format)\n",
    "        \n",
    "        # Derive a day range to loop from for the start date\n",
    "        delta = tEnd - tStart\n",
    "    \n",
    "        # Get all the dates between start date and end date\n",
    "        dates = [tStart + timedelta(i) for i in range(delta.days + 1)]\n",
    "        \n",
    "        # Parse them to the appropriate format\n",
    "        dates = [dt.strftime(elem, date_format) for elem in dates]\n",
    "        \n",
    "        # Generate an iterator with all inputs for the flight scraper\n",
    "        city_input_pairs = product(destinations, destinations)\n",
    "        \n",
    "        # De-duplicate (city of arrival == city of departure)\n",
    "        city_pairs = [[city_from, city_to] for (city_from, city_to) in city_input_pairs if city_from != city_to]\n",
    "        \n",
    "        # Generate list of dicts containing the inputs for each process\n",
    "        flight_scraper_inputs = []\n",
    "        \n",
    "        for idx, elem in enumerate(product(city_pairs, dates)):\n",
    "            \n",
    "            city_from       = elem[0][0]\n",
    "            city_to         = elem[0][1]\n",
    "            departure_dates = list(elem[1])\n",
    "            \n",
    "            inputs = {\"no_adults\" :      no_adults,\n",
    "                      \"city_from\" :      [city_from],\n",
    "                      \"city_to\" :        [city_to],\n",
    "                      \"departure_dates\" : departure_dates,\n",
    "                      \"id\" :              idx}\n",
    "            \n",
    "            flight_scraper_inputs.append(inputs)\n",
    "            \n",
    "        return flight_scraper_inputs\n",
    "        \n",
    "    \n",
    "    # Return a list of inputs for the hotel scraper processes\n",
    "    @staticmethod\n",
    "    def hotel_scraper_input_list(destinations, start_date, end_date, no_adults, date_format):\n",
    "        \n",
    "        # Parse starting and ending dates for the trip\n",
    "        tStart = dt.strptime(start_date, date_format) \n",
    "        tEnd   = dt.strptime(end_date, date_format)\n",
    "        \n",
    "        date_pairs = [] # Empty list to hold the results\n",
    "        \n",
    "        # Derive a day range to loop from for the start date\n",
    "        tRange_outer = range(0, (tEnd - tStart).days + 1)\n",
    "            \n",
    "        # Loop through all the date pairs, and append them to the list\n",
    "        for tStart_outer in (tStart + timedelta(n) for n in tRange_outer):\n",
    "                \n",
    "            # Derive a day range to loop from for the end date\n",
    "            tRange_inner = range(1, (tEnd - tStart_outer).days + 1)\n",
    "                \n",
    "            for date in (tStart_outer + timedelta(n) for n in tRange_inner):\n",
    "                tCursor_end   = dt.strftime(date, date_format)\n",
    "                tCursor_start = dt.strftime(tStart_outer, date_format)\n",
    "                date_pairs.append((tCursor_start, tCursor_end))\n",
    "        \n",
    "        \n",
    "        # Iterate over each destination and each date-pair to create a dataframe\n",
    "        inputs = [] # Empty list to hold the results\n",
    "        \n",
    "        for idx, (destination, date_pair) in enumerate(product(destinations, date_pairs)):\n",
    "            \n",
    "            # Generate a dictionary with the destination included, and a unique set of start dates\n",
    "            temp                 = date_pair.to_dict('list')\n",
    "            temp[\"no_adults\"]    = no_adults\n",
    "            temp['destinations'] = [destination]\n",
    "            temp[\"id\"]           = idx\n",
    "            \n",
    "            # Append to list\n",
    "            inputs.append(temp)\n",
    "        \n",
    "        return inputs\n",
    "    \n",
    "    \n",
    "    # Generate a list of remaining jobIDs to run\n",
    "    def get_remaining_jobs(self):\n",
    "        \n",
    "        # Get all the keys from the file\n",
    "        with pd.HDFStore(self.filename) as hdf:\n",
    "            keys = hdf.keys()\n",
    "        \n",
    "        # Get the job id from each key\n",
    "        finished_jobs =[elem.replace('/', '') for elem in keys]\n",
    "        \n",
    "        # Construct job id for all the jobs we want to perform\n",
    "        all_jobs = ['job_' + str(elem) for elem in range(self.max_job + 1)]\n",
    "        \n",
    "        # Get the job IDs that need to be performed\n",
    "        remaining_jobs = list(set(all_jobs) - set(finished_jobs))\n",
    "        \n",
    "        return remaining_jobs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. Next up, let's write our worker process. This will start a virtual display, fire up the appropriate scraper (for flights or hotels), scrape the data we want, put them to queue for the listener to collect it, and close the browser and the virtual display:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Scraper\n",
    "\n",
    "    # Worker to scrape data\n",
    "    def worker(self, job_id, args, queue): \n",
    "        \n",
    "        # Start virtual display\n",
    "        xvfb_display = start_xvfb()\n",
    "        \n",
    "        # Start up the appropriate scraper instance\n",
    "        if self.scrape_type == 'hotel':\n",
    "            scraper = Hotel_Scraper()\n",
    "            \n",
    "        elif self.scrape_type == 'flight':\n",
    "            scraper = Flight_Scraper()\n",
    "            \n",
    "        # Put it to work\n",
    "        df = scraper.run(args)\n",
    "        \n",
    "        # Put the result to the queue\n",
    "        queue.put((job_id, df))\n",
    "        \n",
    "        # Close the virtual display\n",
    "        stop_xvfb(xvfb_display)\n",
    "    \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we need the listener() process. This will monitor the queue containing results from the workers, and as soon as any results have been inserted to the queue, it will write them to a CSV file:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%add_to Scraper\n",
    "\n",
    "    # Listen for messages on the queue (q) and writes to file\n",
    "    @staticmethod\n",
    "    def listener(filename, queue, processes_running):\n",
    "        \n",
    "        # While the processes are still running or the queue is not empty:\n",
    "        while (not processes_running.ready()) or (not queue.empty()):\n",
    "    \n",
    "            # Grab an item from the queue\n",
    "            df = queue.get(block = True)\n",
    "            \n",
    "            if not df.empty:\n",
    "                \n",
    "                with open(filename, 'a') as f:\n",
    "                    df.to_csv(f, header = False)\n",
    "            \n",
    "            # Wait a bit\n",
    "            sleep(2)\n",
    "        \n",
    "        return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. Now we just need to put the scrapers to work:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # ----------------------- Scrape Hotels --------------------------------\n",
    "    scraper = Scraper(filename     = 'hotels.csv',\n",
    "                      scrape_type  = 'hotel',\n",
    "                      max_job      = 4959,\n",
    "                      no_processes =  cpu_count() - 1) # cpu_count() - 1\n",
    "    \n",
    "    \n",
    "    scraper.run(destinations = ['Wroclaw', 'Bilbao', 'Colmar', 'Hvar', 'Riga', 'Milan', 'Athens', 'Budapest', 'Lisbon', 'Bohinj'], # https://www.europeanbestdestinations.com/european-best-destinations-2018/ \n",
    "                start_date = \"01/07/2019\", \n",
    "                end_date = \"01/08/2019\", \n",
    "                no_adults = 2)\n",
    "    \n",
    "    \n",
    "    # ----------------------- Scrape Flights --------------------------------\n",
    "    scraper = Scraper(filename     = 'flights.csv',\n",
    "                      scrape_type  = 'flight',\n",
    "                      max_job      = 2879,\n",
    "                      no_processes = cpu_count() - 1)\n",
    "        \n",
    "        \n",
    "    scraper.run(destinations = ['Wroclaw', 'Bilbao', 'Colmar', 'Hvar', 'Riga', 'Milan', 'Athens', 'Budapest', 'Lisbon', 'Bohinj', 'Amsterdam'],\n",
    "                start_date   = \"01/07/2019\", \n",
    "                end_date     = \"01/08/2019\", \n",
    "                no_adults    = 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Results\n",
    "\n",
    "<a id=\"scrape_res\"></a>\n",
    "\n",
    "This took some time.. Now, we have two files, containing all the data we want:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>city</th>\n",
       "      <th>check_in</th>\n",
       "      <th>check_out</th>\n",
       "      <th>hotel</th>\n",
       "      <th>stars</th>\n",
       "      <th>offered_by</th>\n",
       "      <th>price</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>Athens</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>08/01/2019</td>\n",
       "      <td>Hotel Niki</td>\n",
       "      <td>3</td>\n",
       "      <td>Hotel Website</td>\n",
       "      <td>4081</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>Athens</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>07/02/2019</td>\n",
       "      <td>Hotel Divani Palace Acropolis</td>\n",
       "      <td>5</td>\n",
       "      <td>Booking.com</td>\n",
       "      <td>125</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>Athens</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>07/03/2019</td>\n",
       "      <td>Royal Olympic Hotel</td>\n",
       "      <td>5</td>\n",
       "      <td>Expedia</td>\n",
       "      <td>279</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>Athens</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>07/04/2019</td>\n",
       "      <td>Acropolis View Hotel</td>\n",
       "      <td>3</td>\n",
       "      <td>Hotels.com</td>\n",
       "      <td>314</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>Athens</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>07/05/2019</td>\n",
       "      <td>Royal Olympic Hotel</td>\n",
       "      <td>5</td>\n",
       "      <td>Expedia</td>\n",
       "      <td>564</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "     city    check_in   check_out                          hotel  stars  \\\n",
       "0  Athens  07/01/2019  08/01/2019                     Hotel Niki      3   \n",
       "1  Athens  07/01/2019  07/02/2019  Hotel Divani Palace Acropolis      5   \n",
       "2  Athens  07/01/2019  07/03/2019            Royal Olympic Hotel      5   \n",
       "3  Athens  07/01/2019  07/04/2019           Acropolis View Hotel      3   \n",
       "4  Athens  07/01/2019  07/05/2019            Royal Olympic Hotel      5   \n",
       "\n",
       "      offered_by  price  \n",
       "0  Hotel Website   4081  \n",
       "1    Booking.com    125  \n",
       "2        Expedia    279  \n",
       "3     Hotels.com    314  \n",
       "4        Expedia    564  "
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "hotels = pd.read_excel('./data/hotels.xlsx')\n",
    "hotels.head(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. So, in this dataframe we have the best (according to Trivago) hotel, for staying in every one of our destinations, for all combinations of check-in and check-out dates.  Let's see what's in the flights file:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>city_from</th>\n",
       "      <th>city_to</th>\n",
       "      <th>date</th>\n",
       "      <th>flight</th>\n",
       "      <th>departure</th>\n",
       "      <th>arrival</th>\n",
       "      <th>price</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>Amsterdam</td>\n",
       "      <td>Wroclaw</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>KLM KL1271</td>\n",
       "      <td>11:50</td>\n",
       "      <td>13:35</td>\n",
       "      <td>292</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>Amsterdam</td>\n",
       "      <td>Bilbao</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>KLM KL1685</td>\n",
       "      <td>09:15</td>\n",
       "      <td>11:20</td>\n",
       "      <td>384</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>Amsterdam</td>\n",
       "      <td>Colmar</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>EasyJet EZY1045</td>\n",
       "      <td>19:00</td>\n",
       "      <td>20:20</td>\n",
       "      <td>234</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>Amsterdam</td>\n",
       "      <td>Hvar</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>EasyJet EZY7997</td>\n",
       "      <td>12:50</td>\n",
       "      <td>15:00</td>\n",
       "      <td>500</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>Amsterdam</td>\n",
       "      <td>Riga</td>\n",
       "      <td>07/01/2019</td>\n",
       "      <td>Air Baltic BT618</td>\n",
       "      <td>10:20</td>\n",
       "      <td>13:35</td>\n",
       "      <td>234</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   city_from  city_to        date            flight departure arrival  price\n",
       "0  Amsterdam  Wroclaw  07/01/2019        KLM KL1271     11:50   13:35    292\n",
       "1  Amsterdam   Bilbao  07/01/2019        KLM KL1685     09:15   11:20    384\n",
       "2  Amsterdam   Colmar  07/01/2019   EasyJet EZY1045     19:00   20:20    234\n",
       "3  Amsterdam     Hvar  07/01/2019   EasyJet EZY7997     12:50   15:00    500\n",
       "4  Amsterdam     Riga  07/01/2019  Air Baltic BT618     10:20   13:35    234"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "flights = pd.read_excel('./data/flights.xlsx')\n",
    "flights.head(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here, we have flights from every city in our list (including the home node: Amsterdam), towards every other city in our list, for every date between July 1st to August 1st. From here on we can focus on solving the question at hand, as we have all the data we need. \n",
    "\n",
    "# Optimisation Problem\n",
    "<a id=\"opt_prob\"></a>\n",
    "\n",
    "The problem we are trying to solve can be formulated as a binary integer linear programming (BILP) problem. This type of problems can be solved efficiently by a variety of algorithms, from which we can choose and write our own, but there's already a python library we can utilize, called [PuLP](https://coin-or.github.io/pulp/). In the following, we'll (a) formulate the optimisation the problem, and (b) solve it using PuLP instead of implementing our own algorithm from scratch.\n",
    "\n",
    "## Formulation\n",
    "\n",
    "<a id=\"formulation\"></a>\n",
    "\n",
    "In the following, we'll introduce our decision variables, the objective function to be minimised, along with the necessary constraints. We'll also introduce the necessary notation as we go along:\n",
    "\n",
    "### Decision Variables\n",
    "First of all, we need to introduce some notation, along with our decision variables:\n",
    "* $x_{f}^{o,d,t} \\in Z_2^{p(p-1)q}$ are binary decision variables, one for each flight in the dataset, having a value of 1 if a flight is active (i.e. to be taken), or 0 if it is not active. $o$ refers to the outbound city (origin), $d$ refers to the inbound city (destination), and $t$ is the day of travel. The total number of variables is $q$ (number of days in the dataset), times $p(p-1)$, as the same city cannot be an origin and a destination at the same time.\n",
    "* $x_{h}^{o,t_b,t_e} \\in Z_2^{pq(q+1)/2}$ are, again, binary decision variables, one for each hotel, denoted by subscipt $o$ and duration of stay $(t_b, t_e)$, with $t_b$ being the day we'll start occupying a room in the hotel, and $t_e$, the day we'll depart from it. Note that, the number of elements is $p$ (one hotel for each city) times $q(q+1)/2$, which is the number of all possible stay durations (equal to the number of elements in the upper triangle of a square matrix). If, for example, we check-in on the 13th of July, we can only checkout on the days that follow (on the 14th, 15th etc), not the preceding ones (12th, 11th, etc).\n",
    "\n",
    "where: \n",
    "* $C$ refers to the set of cities that will be visited, $p$ is the total number of cities, and $c = 0$ is the home node, from which we have to start and finish our trip.\n",
    "* $T$ refers to the set of days between July 1st ($t_0$) to August 1st, with $q$ being the total number of days between our one month time span.\n",
    "\n",
    "### Objective function\n",
    "\n",
    "The objective function is the total cost of our holidays, i.e. cost of every hotel and every flight we take:\n",
    "\n",
    "$$min_{\\bar{x}_f, \\bar{x}_h} = \\sum_{i = 1}^{p} \\sum_{j = 1, j \\neq i}^{p} \\sum_{k = 1}^{q} c_{f}^{i,j,k} x_{f}^{i,j,k} + \\sum_{i = 1}^{p} \\sum_{j = 1}^{q} \\sum_{k = j + 1}^{q} c_{h}^{i, j, k} x_{h}^{i, j, k}$$\n",
    "\n",
    "with:\n",
    "\n",
    "* $c_{f}^{o,d,t} \\in R^{p(p-1)q}$ are the costs of flying from city $o$ (origin) to city $d$ (destination) at time $t$\n",
    "* $c_{h}^{o,t_b,t_e} \\in R^{pq(q+1)/2}$ are the costs of staying at city $o$, from day $t_b$ to day $t_e$.\n",
    "\n",
    "### Constraints\n",
    "\n",
    "While the objective function is easy to deduct, the constraints require a bit more work:\n",
    "\n",
    "First of all, we need to make sure that we start our holidays from the home node, and we also arrive back to the home node at the end of the holiday period. This means that there must be exactly one flight from the home node $c = 0$ (Amsterdam) at time $t = 0$, and exactly one flight towards the home node at the end $t = t_q$. All flights with a different outbound city in the dataset are not allowed:\n",
    "\n",
    "$$ \\begin{align}\n",
    "\\sum_{j = 1}^{p} x_f^{c_0, j, t_0} &= 1 \\\\ \n",
    " \\sum_{j = 1}^{p} x_f^{j, c_0, t_q} &= 1 \\\\\n",
    " \\sum_{j = 1, j \\neq c}^{p} x_f^{c, j, t_0} &= 0,~ \\forall c \\in C \\\\\n",
    " \\sum_{j = 1, j \\neq c}^{p} x_f^{j, c, t_q} &= 0,~ \\forall c \\in C\n",
    " \\end{align}$$\n",
    "\n",
    "Moreover, we have to make sure that each city is visited at most once (apart from the home node). This also means that there is at most one flight towards every destination, and one flight from every origin:\n",
    "\n",
    "$$ \\begin{align}\n",
    "\\sum_{i = 0}^{q} \\sum_{j = 1 + 1}^{q} x_h^{c, i, j} &\\leq 1,~\\forall \\{c \\in C~|~c \\neq 0 \\} \\\\\n",
    "\\sum_{i = 0}^{p} \\sum_{j = 0}^{q} x_f^{i,c,j} &\\leq 1,~\\forall c \\in C \\\\\n",
    "\\sum_{i = 0}^{p} \\sum_{j = 0}^{q} x_f^{c,i,j} &\\leq 1,~\\forall c \\in C\n",
    "\\end{align} $$\n",
    "\n",
    "Each hotel stay must be accompanied by the corresponding inbound and outbound flight (there's no way to get to a city without taking a flight towards it, and you can't get out with another flight):\n",
    "\n",
    "$$\n",
    "x_f^{i,c,t_b} = x_h^{c,t_b,t_e} = x_f^{c, i, t_e},~\\forall t_b \\in T, ~ \\forall t_e > t_b\\in T, ~\\forall c \\in C\n",
    "$$\n",
    "\n",
    "At least $N$ cities will be visited. For cost minimisation (if the problem is formulated properly), this essentially means that exactly $N$ cities will be visited. Furthermore, at least $N + 1$ flights will be taken (+ 1 to return to the home node at the end):\n",
    "\n",
    "$$\n",
    "\\begin{align}\n",
    "\\sum_{i = 1}^{p} \\sum_{j = 0}^{q} \\sum_{k = j + 1}^{q} x_h^{i,j,k} &\\leq N \\\\\n",
    "\\sum_{i = 1}^{p} \\sum_{j = 0, j \\neq i}^{p} \\sum_{k = 1}^{q} x_f^{i,j,k} &\\leq N + 1\n",
    "\\end{align}\n",
    "$$\n",
    "\n",
    "Finally, we need to implement a minimum stay duration of $K$ days at each city , apart from the home node. This means that, if a city is visited on a certain date, we need to restrict all outgoing flights for the next $K$ days. The equality constraints introduced above will then ensure that any other hotel stays for the next $K$ days will be zeroed out. This can be implemented with the following set of big-M constraints:\n",
    "\n",
    "$$\n",
    "\\sum_{i = 1}^{p} \\sum_{j = J}^{q} x_{f}^{c,i,j} \\leq M \\left(1 - \\sum_{i = 1}^{p} \\sum_{j=J}^{J+K} x_{f}^{i,c,k}\\right),~\\forall\\{c \\in C~|~c \\neq 0 \\},~\\forall \\{J \\in T ~| ~J \\leq q - K\\}\n",
    "$$\n",
    "\n",
    "The above works for all intermediate nodes. We need to set the following constraints to- and from- the home node:\n",
    "\n",
    "$$\n",
    "\\begin{align}\n",
    "\\sum_{i = 0}^{p} \\sum_{j = 0}^{p} \\sum_{k = 1}^{K} x_f{i,j,k} &= 0 \\\\\n",
    "\\sum_{i = 1}^{p} \\sum_{j = 1}^{K} \\sum_{k = j + 1}^{K+ 1} x_h^{i,j,k} &= 0\n",
    "\\end{align}\n",
    "$$\n",
    "\n",
    "And that's about it. Next, code it all:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## PuLP programming\n",
    "\n",
    "<a id=\"pulp\"></a>\n",
    "\n",
    "PuLP has a fairly intuitive way of formulating the problem. In the following, we'll instantiate the problem, add one by one the constraints followed by the objective function, and then get the solution to the problem.\n",
    "\n",
    "First of all let's generate the necessary constants, and instantiate the problem:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # Necessary constants\n",
    "    t0 = \"07/01/2019\"\n",
    "    tq = \"08/01/2019\"\n",
    "    c0 = \"Amsterdam\"\n",
    "    K  = 4\n",
    "    N  = 6 + 1 # Plus one for the home node\n",
    "    M  = 1e9\n",
    "    C  = flights['city_from'].unique()\n",
    "    T  = flights['date'].unique()\n",
    "    cf = flights.set_index(['city_from', 'city_to', 'date'])\n",
    "    ch = hotels.set_index(['city', 'check_in', 'check_out'])\n",
    "    C.sort()\n",
    "    T.sort()\n",
    "    \n",
    "    # Instantiate problem\n",
    "    model = plp.LpProblem(\"Traveling Costs\", plp.LpMinimize)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, let's generate our decision variables:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # Generate decision variables\n",
    "    xf = plp.LpVariable.dicts(\"xf\", ((from_city, to_city, at_date) \\\n",
    "                                     for from_city, to_city, at_date in cf.index),\n",
    "                              cat = 'Binary')\n",
    "    \n",
    "    xh = plp.LpVariable.dicts(\"xh\", ((city, check_in, check_out) \\\n",
    "                                     for city, check_in, check_out in ch.index),\n",
    "                              cat = 'Binary' )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Right. Now we'll start adding up our constraints in the same order as they appeared earlier. First of all, we'll code the constraints that ensure we'll start and finish our holidays at the home node:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # Starting flight only from AMS at 07/01/2019\n",
    "    cf_from_c0_at_t0 = [xf[c0, to_city, t0] for to_city in C if to_city != c0]\n",
    "    \n",
    "    model += plp.lpSum(cf_from_c0_at_t0) == 1, \"Starting flight only from AMS at 07/01/2019 constraint 1/2\" \n",
    "    \n",
    "    cf_not_from_c0_at_t0 = [xf[from_city, to_city, t0] \\\n",
    "                            for from_city, to_city in product(C, C) \\\n",
    "                            if from_city != to_city and from_city != c0 and to_city != c0]\n",
    "    \n",
    "    model += plp.lpSum(cf_not_from_c0_at_t0) == 0, \"Starting flight only from AMS at 07/01/2019 constraint 2/2\" \n",
    "    \n",
    "    # Returning flight only to AMS at 08/01/2019\n",
    "    cf_towards_c0_on_tq = [xf[from_city, c0, tq] for from_city in C if from_city != c0]\n",
    "    \n",
    "    model += plp.lpSum(cf_towards_c0_on_tq) == 1, \"Returning flight only to AMS at 08/01/2019 - constraint 1/2\" \n",
    "\n",
    "    cf_not_towards_c0_on_tq = [xf[from_city, to_city, tq] \\\n",
    "                               for from_city, to_city, at_date in cf.index \\\n",
    "                               if to_city != c0 and at_date == tq]\n",
    "    \n",
    "    model += plp.lpSum(cf_not_towards_c0_on_tq) == 0, \"Returning flight only to AMS at 08/01/2019 - constraint 2/2\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, the constraints indicating that each city must be visited at most once:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "     # At most one visit (check in / check out pair) per city\n",
    "    for city_name in C:\n",
    "        if city_name != c0:\n",
    "            \n",
    "            possible_checkins_at_city = [xh[city, check_in, check_out]\n",
    "                                         for city, check_in, check_out in ch.index if city == city_name]\n",
    "            \n",
    "            model += plp.lpSum(possible_checkins_at_city) <= 1, \"At most one visit at {}\".format(city_name)\n",
    "    \n",
    "    # At most one flight connecting any two cities\n",
    "    for city_1, city_2 in product(C, C):\n",
    "        \n",
    "        if city_1 != city_2 and city_1 != c0 and city_2 != c0: # (c0 is the only city with two flights. One at the beginning and one at the end of the holidays)\n",
    "            \n",
    "            cf_from_city1_to_city2 = [xf[city_1, city_2, at_date] for at_date in T]\n",
    "            cf_from_city2_to_city1 = [xf[city_2, city_1, at_date] for at_date in T]\n",
    "            \n",
    "            model += plp.lpSum(cf_from_city1_to_city2) + plp.lpSum(cf_from_city2_to_city1) <= 1, \\\n",
    "            \"Travel between {} and {} at most once\".format(city_1, city_2)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Very good. Next, we need to manage our connections between cities. That requires a bit more code:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # Manage connections: Flight at_date must match check_in at_date for inbound city and check_out at_date for the outbound city\n",
    "    for from_city, to_city, flight_date in cf.index:\n",
    "        \n",
    "        # Is it the first flight we'll take as we start out?\n",
    "        initial_flight = from_city == c0 and flight_date == t0\n",
    "        \n",
    "        # Is it the final flight we'll take (going c0)?\n",
    "        final_flight = to_city == c0 and flight_date == tq\n",
    "        \n",
    "        # Is it a flight from leaving from c0, or returning to c0?\n",
    "        intermediate_flight = not(initial_flight) and not(final_flight)\n",
    "        \n",
    "       \n",
    "        if intermediate_flight:\n",
    "            current_flight = xf[from_city, to_city, flight_date]\n",
    "            \n",
    "            prior_possible_checkouts_if_on_current_flight = [xh[from_city, from_date, flight_date] \\\n",
    "                                                             for from_date in remaining_T(T, flight_date, 'pre') \\\n",
    "                                                             if from_date != flight_date]\n",
    "            \n",
    "            post_possible_checkins_if_on_current_flight = [xh[to_city, flight_date, at_date] \\\n",
    "                                                            for at_date in remaining_T(T, flight_date, 'post') \\\n",
    "                                                            if at_date != flight_date]\n",
    "            \n",
    "            # Check out at_date <check-out> for city <city from> matching flight <city from> at at_date <check-out>\n",
    "            model += current_flight <= plp.lpSum(prior_possible_checkouts_if_on_current_flight), \\\n",
    "            'Check out: traveling from {} to {} at {}'.format(from_city, to_city, flight_date)\n",
    "        \n",
    "            # Check in at_date <check-in> for city <city to> matching flight <city to> at at_date <check-in>\n",
    "            model += current_flight <= plp.lpSum(post_possible_checkins_if_on_current_flight), \\\n",
    "            'Check_in: traveling from {} to {} at {}'.format(from_city, to_city, flight_date)\n",
    "\n",
    "        elif initial_flight:\n",
    "            # Check in at hotel of first city\n",
    "            current_flight = xf[from_city, to_city, flight_date]\n",
    "            \n",
    "            post_possible_checkins_if_on_current_flight = [xh[to_city, flight_date, from_date] \\\n",
    "                                                           for from_date in remaining_T(T, flight_date, 'post') \\\n",
    "                                                           if from_date != flight_date]\n",
    "            \n",
    "            model += current_flight == plp.lpSum(post_possible_checkins_if_on_current_flight), \\\n",
    "            'Check_in: traveling from {} to {} at {}'.format(from_city, to_city, flight_date)\n",
    "        \n",
    "        elif final_flight: \n",
    "            \n",
    "            current_flight = xf[from_city, to_city, flight_date]\n",
    "            \n",
    "            prior_possible_checkouts_if_on_current_flight = [xh[from_city, from_date, flight_date] \\\n",
    "                                                             for from_date in remaining_T(T, flight_date, 'pre') \\\n",
    "                                                             if from_date != flight_date]\n",
    "            \n",
    "            # Check out of hotel of last city \n",
    "            model += current_flight == plp.lpSum(prior_possible_checkouts_if_on_current_flight), \\\n",
    "            'Check_out: traveling from {} to {} at {}'.format(from_city, to_city, flight_date)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Right, next we need to incorporate the minimum stay duration constraints:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # Minimum stay at each city = No flights allowed before and after N days\n",
    "    for cur_city, cur_date in product(C, T):\n",
    "        if cur_city != c0 and cur_date != tq:\n",
    "            \n",
    "            cf_from_current_city_at_current_date = [xf[from_city, to_city, at_date] \\\n",
    "                                                    for from_city, to_city, at_date in cf.index \\\n",
    "                                                    if to_city == cur_city and at_date == cur_date]\n",
    "            \n",
    "            no_flight_dates = remaining_T(T, cur_date, 'post')[0 : K - 1] \n",
    "            \n",
    "            forbidden_cf_from_current_city_at_current_date = [xf[from_city, to_city, at_date] \\\n",
    "                                                              for from_city, to_city, at_date in cf.index \\\n",
    "                                                              if from_city == cur_city and at_date in no_flight_dates]\n",
    "        \n",
    "            x = plp.lpSum(cf_from_current_city_at_current_date)\n",
    "            y = plp.lpSum(forbidden_cf_from_current_city_at_current_date)\n",
    "        \n",
    "            # If x == 1: y == 0 else if x == 0: y >= 0 -> y <= M(1-x)\n",
    "            model += y <= M * (1 - x), 'Minimum stay at {} if visited on {}'.format(cur_city, cur_date)\n",
    "            \n",
    "    \n",
    "    # No flights or checkins allowed after the start date for at least N days\n",
    "    forbidden_flight_dates = remaining_T(T, t0, 'post')[0 : K - 1]\n",
    "    \n",
    "    forbidden_cf = [xf[from_city, to_city, at_date] \\\n",
    "                    for from_city, to_city, at_date in cf.index if at_date in forbidden_flight_dates]\n",
    "    \n",
    "    model += plp.lpSum(forbidden_cf) == 0, 'Minimum stay on first node - cf'\n",
    "    \n",
    "    # No checkins allowed after the start date for at least N days    \n",
    "    for cur_city in C:\n",
    "        if cur_city != c0:\n",
    "            \n",
    "            forbidden_checkins = [xh[cur_city, check_in, check_out] \\\n",
    "                                  for cur_city, check_in, check_out in ch.index \\\n",
    "                               if check_in == cur_date and check_out in forbidden_flight_dates]\n",
    "            \n",
    "            model += plp.lpSum(forbidden_checkins) == 0, \"Minimum stay on first node - ch at {}\".format(cur_city)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we have to make sure that at least (or exactly) N cities will be visited:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# At least N cities must be visited: at least N check ins + at least (N + 1) flights\n",
    "    total_checkins = [xh[city, from_date, to_date] for city, from_date, to_date in ch.index if city != c0]\n",
    "    \n",
    "    model += plp.lpSum(total_checkins) >= N, \"No cities to visit\"\n",
    "    \n",
    "    total_cf = [xf[from_city, to_city, at_date] for from_city, to_city, at_date in cf.index]\n",
    "        \n",
    "    model += plp.lpSum(total_cf) >= N + 1, 'No flights to take'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Perfect. That was the final constraint. Let's generate our objective function:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    # Generate objective function\n",
    "    total_flight_costs = [xf[from_city, to_city, at_date] * cf.loc[(from_city, to_city, at_date), \"price\"] \\\n",
    "                          for from_city, to_city, at_date in cf.index]\n",
    "    \n",
    "    total_hotel_costs = [xh[city, check_in, check_out] * ch.loc[(city, check_in, check_out), \"price\"] \\\n",
    "                         for city, check_in, check_out in ch.index]\n",
    "    \n",
    "    model += plp.lpSum(total_flight_costs + total_hotel_costs), \"Total cost minimization\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "That's it. Let's solve the problem (just a one-liner), and collect the results in new dataframes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    model.solve() # Solve the model    \n",
    "    \n",
    "    # Grab results\n",
    "    sol_cf = [cf.loc[from_city, to_city, at_date] \\\n",
    "              for from_city, to_city, at_date in cf.index if xf[from_city, to_city, at_date].varValue == 1]\n",
    "    sol_cf = pd.concat(sol_cf, axis = 1).T\n",
    "    \n",
    "    sol_cf.index = sol_cf.index.set_names(['city_from', 'city_to', 'date'])\n",
    "    sol_cf.reset_index(inplace = True)\n",
    "    \n",
    "    sol_ch = [ch.loc[city, check_in, check_out] \\\n",
    "              for city, check_in, check_out in ch.index if xh[city, check_in, check_out].varValue == 1]\n",
    "    sol_ch = pd.concat(sol_ch, axis = 1).T\n",
    "    \n",
    "    sol_ch.index = sol_ch.index.set_names(['city_from', 'city_to', 'date'])\n",
    "    sol_ch.reset_index(inplace = True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Solution\n",
    "\n",
    "<a id=\"solution\"></a>\n",
    "Let's have a look:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-----------------------------------Flight Schedule-----------------------------------\n",
      "   city_from    city_to        date                 flight departure  arrival  price\n",
      "0  Amsterdam    Wroclaw  07/01/2019             KLM KL1271     11:50    13:35    292\n",
      "1    Wroclaw       Hvar  07/04/2019         Ryanair FR4108     12:30    13:45    250\n",
      "2       Hvar   Budapest  07/10/2019     Laudamotion OE5592   8:05 AM  9:40 AM    112\n",
      "3   Budapest     Colmar  07/14/2019        Wizz Air W62269     13:10    14:55     85\n",
      "4     Colmar      Milan  07/25/2019             KLM KL1990     18:25    19:55    212\n",
      "5      Milan     Athens  07/25/2019  Aegean Airlines A3665     17:45    21:10    189\n",
      "6     Athens  Amsterdam  08/01/2019             KLM KL1576     17:20    19:55    278 \n",
      "\n",
      "\n",
      "-----------------------------------Hotel Schedule-----------------------------------\n",
      "       city    check_in   check_out                                 hotel  stars   offered_by  price\n",
      "0   Wroclaw  07/01/2019  07/04/2019                AC by Marriott Wroclaw      4    AC Hotels    324\n",
      "1      Hvar  07/04/2019  07/10/2019  Hotel Amfora Hvar Grand Beach Resort      4      Expedia    440\n",
      "2  Budapest  07/10/2019  07/14/2019         Hotel Mercure Budapest Korona      4  ebookers.ch    351\n",
      "3    Colmar  07/14/2019  07/18/2019                  James Boutique HÃ´tel      4   Hotels.com    508\n",
      "4     Milan  07/18/2019  07/25/2019                      Room Mate Giulia      5      Expedia    840\n",
      "5    Athens  07/25/2019  08/01/2019              Hotel Grand Hyatt Athens      5  Booking.com    734\n"
     ]
    }
   ],
   "source": [
    "    pd.set_option('expand_frame_repr', False)\n",
    "    \n",
    "    print(\"-----------------------------------Flight Schedule-----------------------------------\")\n",
    "    print(sol_cf, '\\n\\n')\n",
    "    print(\"-----------------------------------Hotel Schedule-----------------------------------\")\n",
    "    print(sol_ch)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Beautiful. We could also implement additional constraints, like no. stars on each hotel, or flight arrival times etc. (I don't like the flight from Milan to Athens, arriving at 9 pm), but it should be fairly easy to implement those...\n",
    "\n",
    "Enjoy your holidays everyone!!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}

